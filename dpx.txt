""" distance preserving crossover"""
	def dpx_crossover(self,p1,p2,nlen,distanceMatrix,consumed_time):
				
		"""
		pick random start node that has 0 or 1 edges
		if the node has an edge in child_graph (child graph con	
		if(comparison.all()):
			#print("ordered")
			child = self.ordered_crossover(p1,p2,nlen,consumed_time)
			return child
		l = len(t1)-1
		tmptour = t1

		#create graph structure of p1
		graph_p1 = {} #dictionairy that represents the graph
		graph_p1[t1[0]] = [t1[1],t1[l]] #edges of the first node
		for i in range(1,l):
			graph_p1[t1[i]] = [t1[i+1],t1[i-1]]
		graph_p1[t1[l]] = [t1[0],t1[l-1]]
		#print("graph: ", graph_p1)

		#create graph structure of p2
		graph_p2 = {} #dictionairy that represents the graph
		graph_p2[t2[0]] = [t2[1],t2[l]] #edges of the first node
		for i in range(1,l):
			graph_p2[t2[i]] = [t2[i+1],t2[i-1]]
		graph_p2[t2[l]] = [t2[0],t2[l-1]]
		#print("graph2: ", graph_p2)

		#remove edges that are only common in 1 parent
		child_graph = {}

		#print("graph_p1: ", graph_p1)
		#print("graph_p2: ", graph_p2)
		#graph with edges that are pressent in both parents
		for i in range(l+1):
			child_graph[i] = [x for x in graph_p1[i] if x  in graph_p2[i]]
		
		
		#print("child graph: ", child_graph)

		single_edge_nodes = list()
		zero_or_single_edge_nodes = list()
		double_edge_nodes = list()
		for i in range(len(child_graph)):
			if len(child_graph[i]) == 2:
				double_edge_nodes.append(i)
			elif len(child_graph[i]) ==1:
				zero_or_single_edge_nodes.append(i)
				single_edge_nodes.append(i)
			elif len(child_graph[i]) == 0:
				zero_or_single_edge_nodes.append(i)
			else:
				print("u fucked up")
		#print("zero/one: ", zero_or_single_edge_nodes)
		#print("double: ", double_edge_nodes)

		child_tour = np.full(nlen,-1)
		if len(zero_or_single_edge_nodes) > 0:
			start = random.choice(zero_or_single_edge_nodes)
			child_tour[0] = start
			zero_or_single_edge_nodes.remove(child_tour[0])
		else:
			start = random.randint(0,nlen-1)
			child_tour[0] = start
			

		for i in range(len(child_tour)-1):
			#print("child tour i: ", child_tour[i])
			#print("zero and singles: ", zero_or_single_edge_nodes)
			if len(child_graph[child_tour[i]]) != 0:
				#print("in if")
				child_tour[i+1] = child_graph[child_tour[i]][0]
				child_graph[child_tour[i]].pop(0) # remove edge between child_tour[i] and child_tour[i+1]
				child_graph[child_tour[i+1]].remove(child_tour[i]) # remove edge between child_tour[i+1] and child_tour[i]
				if child_tour[i+1] in zero_or_single_edge_nodes:
					zero_or_single_edge_nodes.remove(child_tour[i+1])		
			else: #node has no edges left 
				#print("in else")
				#zero_or_single_edge_nodes.remove(child_tour[i])

				#calculate the distance to all start nodes
				distances = list()
				for node in zero_or_single_edge_nodes:
					distances.append(distanceMatrix[child_tour[i]][node])

				#todo makes no sense pop => indeces are different in distances => dont match indices in zero_or_single_edge_nodes
				#sort zero_or_single_edge_nodes according to distance and than for loop over the nodes instead of while!
				#print("distances: ", distances)
				#print("zero and ones: ", zero_or_single_edge_nodes)
				zero_or_single_edge_nodes = sorted(zero_or_single_edge_nodes,key=lambda x:distances[zero_or_single_edge_nodes.index(x)])
				#print("sorted zero: ", zero_or_single_edge_nodes)

				for j,node in enumerate(zero_or_single_edge_nodes):
					if node not in graph_p1[child_tour[i]] and node not in graph_p2[child_tour[i]]:
						child_tour[i+1] = node
						zero_or_single_edge_nodes.remove(node)
						break
					else: 
						#print("in parents")
						if  j == len(zero_or_single_edge_nodes)-1:#last node in list => add this one
							child_tour[i+1] = node
							zero_or_single_edge_nodes.remove(node)
							#print("last node added")
			

		#print("child tour: ", child_tour)
		#to test	
		default_tour = np.arange(0,nlen)
		tourcop = copy.deepcopy(child_tour)
		tourcop.sort()
		valid = default_tour == tourcop
		if(valid.all()):
			None
		else:
			print("bad tour: ")
			print(child_tour)

		alpha = 0.25 + consumed_time/300 * 0.3 #increase alpha over time
		child = Individual(child_tour,alpha)
		return child